    #version 300 es
//  #version 300 es
    precision  lowp float;
//  precision  lowp float;

    uniform         sampler2D          tex0;
//  uniform         sampler2D          tex0;
    in              vec2          vTexCoord;
//  in              vec2          vTexCoord;
    out             vec4          fragColor;
//  out             vec4          fragColor;
    uniform         float              time;
//  uniform         float              time;
    uniform         vec2         canvasSize;
//  uniform         vec2         canvasSize;
    uniform         vec2          texelSize;
//  uniform         vec2          texelSize;
    uniform         vec4      mousePosition;
//  uniform         vec4      mousePosition;

    // const float cloudscale = 1.10;
//  // const float cloudscale = 1.10;
    // const float speed      = 0.03;
//  // const float speed      = 0.03;
    // const float clouddark  = 0.50;
//  // const float clouddark  = 0.50;
    // const float cloudlight = 0.30;
//  // const float cloudlight = 0.30;
    // const float cloudcover = 0.20;
//  // const float cloudcover = 0.20;
    // const float cloudalpha = 8.00;
//  // const float cloudalpha = 8.00;
    // const float skytint    = 0.50;
//  // const float skytint    = 0.50;
    // const vec3  skycolour1 = vec3(0.2, 0.4, 0.6);
//  // const vec3  skycolour1 = vec3(0.2, 0.4, 0.6);
    // const vec3  skycolour2 = vec3(0.4, 0.7, 1.0);
//  // const vec3  skycolour2 = vec3(0.4, 0.7, 1.0);


    uniform float cloudscale ; // 1.10
//  uniform float cloudscale ; // 1.10
    uniform float speed      ; // 0.03
//  uniform float speed      ; // 0.03
    uniform float clouddark  ; // 0.50
//  uniform float clouddark  ; // 0.50
    uniform float cloudlight ; // 0.30
//  uniform float cloudlight ; // 0.30
    uniform float cloudcover ; // 0.20
//  uniform float cloudcover ; // 0.20
    uniform float cloudalpha ; // 8.00
//  uniform float cloudalpha ; // 8.00
    uniform float skytint    ; // 0.50
//  uniform float skytint    ; // 0.50
    uniform vec3  skycolour1 ; // 0.2, 0.4, 0.6
//  uniform vec3  skycolour1 ; // 0.2, 0.4, 0.6
    uniform vec3  skycolour2 ; // 0.4, 0.7, 1.0
//  uniform vec3  skycolour2 ; // 0.4, 0.7, 1.0


    const mat2 m = mat2( 1.6, 1.2, -1.2, 1.6 );
//  const mat2 m = mat2( 1.6, 1.2, -1.2, 1.6 );

    vec2 hash( vec2 p ) {
//  vec2 hash( vec2 p ) {
    p =    vec2(dot(p, vec2(127.1, 311.7))
//  p =    vec2(dot(p, vec2(127.1, 311.7))
    ,         dot(p, vec2(269.5, 183.3)));
//  ,         dot(p, vec2(269.5, 183.3)));
    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);
//  return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);
    }
//  }

    float noise( vec2 p ) {
//  float noise( vec2 p ) {
    const float K1 = 0.366025404; // (    sqrt(3) - 1) / 2;
//  const float K1 = 0.366025404; // (    sqrt(3) - 1) / 2;
    const float K2 = 0.211324865; // (3 - sqrt(3)    ) / 6;
//  const float K2 = 0.211324865; // (3 - sqrt(3)    ) / 6;
    vec2 i = floor(p     + (p.x + p.y) * K1);
//  vec2 i = floor(p     + (p.x + p.y) * K1);
    vec2 a =       p - i + (i.x + i.y) * K2 ;
//  vec2 a =       p - i + (i.x + i.y) * K2 ;
    vec2 o = (a.x > a.y) ?
//  vec2 o = (a.x > a.y) ?
    vec2(1.0 , 0.0) :
//  vec2(1.0 , 0.0) :
    vec2(0.0 , 1.0) ; //vec2 of = 0.5 + 0.5 * vec2(sign(a.x - a.y), sign(a.y - a.x));
//  vec2(0.0 , 1.0) ; //vec2 of = 0.5 + 0.5 * vec2(sign(a.x - a.y), sign(a.y - a.x));
    vec2 b = a - o   +       K2;
//  vec2 b = a - o   +       K2;
    vec2 c = a - 1.0 + 2.0 * K2;
//  vec2 c = a - 1.0 + 2.0 * K2;
    vec3 h = max(0.5 - vec3( dot(a, a)
//  vec3 h = max(0.5 - vec3( dot(a, a)
    ,                 dot(b, b)
//  ,                 dot(b, b)
    ,                 dot(c, c) ), 0.0 );
//  ,                 dot(c, c) ), 0.0 );
    vec3 n = h
//  vec3 n = h
    * h
//  * h
    * h
//  * h
    * h * vec3( dot(a, hash(i + 0.0))
//  * h * vec3( dot(a, hash(i + 0.0))
    ,           dot(b, hash(i + o  ))
//  ,           dot(b, hash(i + o  ))
    ,           dot(c, hash(i + 1.0)));
//  ,           dot(c, hash(i + 1.0)));
    return             dot(n, vec3(70.0    ));
//  return             dot(n, vec3(70.0    ));
    }
//  }

    float fbm(vec2 n) {
//  float fbm(vec2 n) {
    float  total  = 0.0      , amplitude  = 0.1; for (int i = 0; i < 7; i++) {
//  float  total  = 0.0      , amplitude  = 0.1; for (int i = 0; i < 7; i++) {
    total += noise(n) * amplitude       ;
//  total += noise(n) * amplitude       ;
    n  = m  *  n                    ;
//  n  = m  *  n                    ;
    amplitude *= 0.4;
//  amplitude *= 0.4;
    }
//  }
    return total;
//  return total;
    }
//  }

    // -----------------------------------------------
//  // -----------------------------------------------
    // -----------------------------------------------
//  // -----------------------------------------------

    void main(  ) {
    vec2  p     = vTexCoord;
//  vec2  p     = vTexCoord;
    vec2  uv    =           p * vec2(canvasSize.x / canvasSize.y, 1.0);
//  vec2  uv    =           p * vec2(canvasSize.x / canvasSize.y, 1.0);
    float timee =                                                      time * speed;
//  float timee =                                                      time * speed;
    float q     =                                                                   fbm(uv * cloudscale * 0.5);
//  float q     =                                                                   fbm(uv * cloudscale * 0.5);
    
    //ridged noise shape
//  //ridged noise shape
    //ridged noise shape
//  //ridged noise shape
    float r = 0.0;
//  float r = 0.0;
    uv *= cloudscale;
//  uv *= cloudscale;
    uv -= q -  timee;
//  uv -= q -  timee;
    float weight = 0.8;
//  float weight = 0.8;
    for (int i  =  0  ; i < 8; i++) {
//  for (int i  =  0  ; i < 8; i++) {
    r    += abs(weight * noise( uv ));
//  r    += abs(weight * noise( uv ));
    uv    =     m * uv + timee       ;
//  uv    =     m * uv + timee       ;
    weight *= 0.7;
//  weight *= 0.7;
    }
//  }
    
    //noise shape
//  //noise shape
    //noise shape
//  //noise shape
    float f = 0.0;
//  float f = 0.0;
    uv  = p * vec2(canvasSize.x / canvasSize.y, 1.0);
//  uv  = p * vec2(canvasSize.x / canvasSize.y, 1.0);
    uv *= cloudscale;
//  uv *= cloudscale;
    uv -= q -  timee;
//  uv -= q -  timee;
    weight  = 0.7;
//  weight  = 0.7;
    for (int i  = 0; i < 8; i++) {
//  for (int i  = 0; i < 8; i++) {
    f    += weight * noise( uv );
//  f    += weight * noise( uv );
    uv    = m * uv + timee      ;
//  uv    = m * uv + timee      ;
    weight *= 0.6;
//  weight *= 0.6;
    }
//  }
    
    f *= r + f;
//  f *= r + f;
    
    //noise colour
//  //noise colour
    //noise colour
//  //noise colour
    float c = 0.0;
//  float c = 0.0;
    timee   =            time   * speed       * 2.0 ;
//  timee   =            time   * speed       * 2.0 ;
    uv  = p * vec2(canvasSize.x / canvasSize.y, 1.0);
//  uv  = p * vec2(canvasSize.x / canvasSize.y, 1.0);
    uv *= cloudscale * 2.0;
//  uv *= cloudscale * 2.0;
    uv -= q -  timee      ;
//  uv -= q -  timee      ;
    weight  = 0.4;
//  weight  = 0.4;
    for (int i  = 0; i < 7; i++) {
//  for (int i  = 0; i < 7; i++) {
    c    += weight * noise( uv );
//  c    += weight * noise( uv );
    uv    = m * uv + timee      ;
//  uv    = m * uv + timee      ;
    weight *= 0.6;
//  weight *= 0.6;
    }
//  }
    
    //noise ridge colour
//  //noise ridge colour
    //noise ridge colour
//  //noise ridge colour
    float c1 = 0.0;
//  float c1 = 0.0;
    timee    =           time   * speed       * 3.0 ;
//  timee    =           time   * speed       * 3.0 ;
    uv  = p * vec2(canvasSize.x / canvasSize.y, 1.0);
//  uv  = p * vec2(canvasSize.x / canvasSize.y, 1.0);
    uv *= cloudscale * 3.0;
//  uv *= cloudscale * 3.0;
    uv -= q -  timee      ;
//  uv -= q -  timee      ;
    weight  = 0.4;
//  weight  = 0.4;
    for (int i  = 0; i < 7; i++) {
//  for (int i  = 0; i < 7; i++) {
    c1   += abs(weight * noise( uv ));
//  c1   += abs(weight * noise( uv ));
    uv    =     m * uv + timee       ;
//  uv    =     m * uv + timee       ;
    weight *= 0.6;
//  weight *= 0.6;
    }
//  }
    
    c += c1;
//  c += c1;
    
    vec3   skycolour = mix(
//  vec3   skycolour = mix(
    skycolour2,
//  skycolour2,
    skycolour1, p.y);
//  skycolour1, p.y);
    vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight * c), 0.0, 1.0);
//  vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight * c), 0.0, 1.0);
   
    f = cloudcover
//  f = cloudcover
    + cloudalpha
//  + cloudalpha
    * f
//  * f
    * r
//  * r
    ;
//  ;
    
    vec3              result = mix (skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0)
//  vec3              result = mix (skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0)
    , clamp(f                   + c          , 0.0, 1.0));
//  , clamp(f                   + c          , 0.0, 1.0));
    
    fragColor = vec4( result , 1.0 ) * texture(tex0, vTexCoord);
//  fragColor = vec4( result , 1.0 ) * texture(tex0, vTexCoord);
    }




    // https://www.shadertoy.com/view/4tdSWr
//  // https://www.shadertoy.com/view/4tdSWr


